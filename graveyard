#!/bin/bash

# graveyard - Build and installation manager for LSC (Skull compiler)
# Improved version with better error handling, flags, and directory preservation

# Exit codes
readonly E_SUCCESS=0
readonly E_GENERAL=1
readonly E_NO_TARGET=2
readonly E_INVALID_TARGET=3
readonly E_MISSING_DEPS=4
readonly E_COMPILE_FAIL=5
readonly E_INSTALL_FAIL=6

# Define paths and variables
readonly USER_BIN="/usr/bin"
readonly EXEC="lsc"
readonly BUILD_DIR="build"
readonly BIN_DIR="bin"
readonly TARGET_DIR="target"
readonly SRC_DIR="src"
readonly INCLUDE_DIR="includes"
readonly LOG_FILE="log.grv"

# Compiler flags
readonly IMPL_FLAGS="-DSKULL_LIST_H_IMPLEMENTATION -DSKULL_AST_H_IMPLEMENTATION \
 -DSKULL_TOKEN_H_IMPLEMENTATION -DSKULL_LEXER_H_IMPLEMENTATION \
 -DSKULL_PARSER_H_IMPLEMENTATION -DSKULL_TYPES_H_IMPLEMENTATION \
 -DSKULL_UTILS_H_IMPLEMENTATION -DSKULL_ASM_H_IMPLEMENTATION \
 -DSKULL_H_IMPLEMENTATION"

# All valid targets - updated to match README.md
readonly VALID_TARGETS="diff resurrect lsc-compile lsc-remove lsc-recompile lsc-install lsc-uninstall lsc-reinstall clear-log usage"

# Define color codes for terminal output
readonly RED='\033[0;31m'    # Red for errors
readonly GREEN='\033[0;32m'  # Green for success
readonly BLUE='\033[0;34m'   # Blue for info 
readonly YELLOW='\033[0;33m' # Yellow for warnings
readonly NC='\033[0m'        # No Color - reset

# Default flag values
VERBOSE=0
SUPER_QUIET=0
NO_LOG=0
NO_WARN=0

#!/bin/bash

# First, define SKULL_DIR at the top level
SKULL_DIR=""
ORIGINAL_DIR=$(pwd)

# Then modify the navigate_to_skull_dir function
navigate_to_skull_dir() {
    # Only attempt to navigate if SKULL_DIR is set
    if [ -n "$SKULL_DIR" ]; then
        cd "$SKULL_DIR" || {
            echo -e "\033[0;31m[Graveyard_ERROR]: Failed to change to Skull directory: $SKULL_DIR\033[0m" >&2
            exit 1
        }
    fi
}

# And fix the return_to_original_dir function similarly
return_to_original_dir() {
    cd "$ORIGINAL_DIR" || {
        echo -e "\033[0;31m[Graveyard_ERROR]: Failed to return to original directory: $ORIGINAL_DIR\033[0m" >&2
        # Continue despite error
    }
}

# Function to display error messages
error() {
    # Errors are always displayed, regardless of quiet flags
    local message="${RED}[Graveyard_ERROR]: $1${NC}"
    echo -e "$message" >&2
    
    # Log errors unless NO_LOG is set
    if [ $NO_LOG -eq 0 ]; then
        navigate_to_skull_dir
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: $1" >> "$LOG_FILE"
        return_to_original_dir
    fi
}

# Function to display success messages
success() {
    # Success messages are shown unless SUPER_QUIET is set
    if [ $SUPER_QUIET -eq 0 ]; then
        local message="${GREEN}[Graveyard_SUCCESS]: $1${NC}"
        echo -e "$message"
    fi
    
    # Log success unless NO_LOG is set
    if [ $NO_LOG -eq 0 ]; then
        navigate_to_skull_dir
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: $1" >> "$LOG_FILE"
        return_to_original_dir
    fi
}

# Function to display informational messages
info() {
    # Info messages are not shown unless VERBOSE set
    if [ $VERBOSE -eq 1 ]; then
        local message="${BLUE}$1${NC}"
        echo -e "$message"
    fi
    
    # Log info unless NO_LOG is set
    if [ $NO_LOG -eq 0 ]; then
        navigate_to_skull_dir
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] INFO: $1" >> "$LOG_FILE"
        return_to_original_dir
    fi
}

# Function to display warning messages
warning() {
    # Warning messages are shown unless NO_WARN or SUPER_QUIET are set
    if [ $NO_WARN -eq 0 ] && [ $SUPER_QUIET -eq 0 ]; then
        local message="${YELLOW}[Graveyard_WARNING]: $1${NC}"
        echo -e "$message" >&2
    fi
    
    # Log warnings unless NO_LOG is set
    if [ $NO_LOG -eq 0 ]; then
        navigate_to_skull_dir
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] WARNING: $1" >> "$SKULL_DIR/$LOG_FILE"
        return_to_original_dir
    fi
}

# Function to parse arguments
parse_arguments() {
    local args=("$@")
    local found_target=0
    TARGET=""
    
    # Loop through all arguments
    for arg in "${args[@]}"; do
        # Check if argument is a flag
        if [[ "$arg" == -* ]]; then
            case "$arg" in
                -V)
                    VERBOSE=1
                    ;;
                -Q)
                    SUPER_QUIET=1
                    ;;
                --no-log)
                    NO_LOG=1
                    ;;
                --no-warn)
                    NO_WARN=1
                    ;;
                *)
                    warning "Unknown flag: $arg"
                    ;;
            esac
        else
            # If not a flag, check if it's a valid target
            if echo "$VALID_TARGETS" | grep -qw "$arg"; then
                if [ $found_target -eq 0 ]; then
                    TARGET="$arg"
                    found_target=1
                else
                    warning "Multiple targets specified. Using first target: $TARGET, ignoring: $arg"
                fi
            else
                warning "Invalid target or argument: $arg"
            fi
        fi
    done
    
    # Check if we found a target
    if [ $found_target -eq 0 ]; then
        error "No valid target specified"
        show_usage
        exit $E_NO_TARGET
    fi
    
    info "Target: $TARGET"
    info "Flags: Verbose=$VERBOSE, SuperQuiet=$SUPER_QUIET, NoLog=$NO_LOG, NoWarn=$NO_WARN"
}

# Function to locate the Skull directory
find_skull_dir() {
    local head_dir
    head_dir="$(basename "$(pwd)")"
    
    if [ "$head_dir" = "Skull" ] && [ -d "includes" ] && [ -d "src" ]; then
        pwd
        return 0
    else
        # Find all Skull directories in HOME
        local skull_dirs=()
        mapfile -t skull_dirs < <(sudo find "$HOME" -name "Skull" -type d 2>/dev/null)
        
        # Loop through found directories
        for candidate in "${skull_dirs[@]}"; do
            if [ -d "$candidate/includes" ] && [ -d "$candidate/src" ]; then
                echo "$candidate"
                return 0
            fi
        done
    fi
    
    return 1
}

# Function to check if gcc is installed
check_gcc() {
    info "Checking for GCC compiler..."
    
    # Check if gcc is installed and get version
    if command -v gcc >/dev/null 2>&1; then
        local gcc_version
        gcc_version=$(gcc --version | head -n1)
        info "Found GCC: $gcc_version"
        return 0
    fi
    
    # GCC not found, attempt to install it
    warning "GCC compiler not found. Attempting to install..."
    
    # Track installation attempt
    local installation_attempted=0
    local installation_success=0
    
    # Detect package manager and install gcc
    if command -v pacman >/dev/null 2>&1; then
        info "Detected pacman package manager (Arch-based system)"
        installation_attempted=1
        sudo pacman -Sy --noconfirm gcc && installation_success=1
    elif command -v apt >/dev/null 2>&1; then
        info "Detected apt package manager (Debian/Ubuntu-based system)"
        installation_attempted=1
        sudo apt update && sudo apt install -y gcc && installation_success=1
    elif command -v dnf >/dev/null 2>&1; then
        info "Detected dnf package manager (Fedora/RHEL-based system)"
        installation_attempted=1
        sudo dnf install -y gcc && installation_success=1
    elif command -v yum >/dev/null 2>&1; then
        info "Detected yum package manager (CentOS/older RHEL-based system)"
        installation_attempted=1
        sudo yum install -y gcc && installation_success=1
    elif command -v zypper >/dev/null 2>&1; then
        info "Detected zypper package manager (openSUSE-based system)"
        installation_attempted=1
        sudo zypper install -y gcc && installation_success=1
    elif command -v apk >/dev/null 2>&1; then
        info "Detected apk package manager (Alpine Linux)"
        installation_attempted=1
        sudo apk add gcc build-base && installation_success=1
    elif command -v brew >/dev/null 2>&1; then
        info "Detected Homebrew package manager (macOS)"
        installation_attempted=1
        brew install gcc && installation_success=1
    elif command -v port >/dev/null 2>&1; then
        info "Detected MacPorts package manager (macOS)"
        installation_attempted=1
        sudo port install gcc && installation_success=1
    fi
    
    # Check if installation was attempted
    if [ $installation_attempted -eq 0 ]; then
        error "Unable to detect package manager. Please install GCC manually and try again."
        return 1
    fi
    
    # Verify installation was successful
    if [ $installation_success -eq 0 ]; then
        error "Failed to install GCC using the detected package manager."
        return 1
    fi
    
    # Final verification
    if command -v gcc >/dev/null 2>&1; then
        local gcc_version
        gcc_version=$(gcc --version | head -n1)
        success "Successfully installed GCC: $gcc_version"
        return 0
    else
        error "GCC installation appeared to succeed, but gcc command still not found."
        error "Please install GCC manually and try again."
        return 1
    fi
}

# Function to create directories
create_dirs() {
    navigate_to_skull_dir
    mkdir -p "$TARGET_DIR" "$TARGET_DIR/$BUILD_DIR" "$SKULL_DIR/$TARGET_DIR/$BIN_DIR" || {
        error "Failed to create directories"
        return 1
    }
    return_to_original_dir
    return 0
}

# Function to compile source files
compile_sources() {
    # Find all .c files in src directory
    local SRCS
    navigate_to_skull_dir
    SRCS=$(find "$SRC_DIR" -name "*.c" -type f)
    if [ -z "$SRCS" ]; then
        error "No source files found in $$SRC_DIR"
        return 1
    fi

    # Compile each source file to object file
    for src in $SRCS; do
        local obj
        obj="$TARGET_DIR/$BUILD_DIR/$(basename "${src%.c}.o")"
        info "Compiling $src to $obj..."
        gcc -g -Wall -I"$INCLUDE_DIR" $IMPL_FLAGS -c "$src" -o "$obj" || {
            error "Compilation of $src failed"
            return 1
        }
    done
    return_to_original_dir
    return 0
}

# Function to link object files
link_executable() {
    # Find all object files
    local OBJS
    navigate_to_skull_dir
    OBJS=$(find "$TARGET_DIR/$BUILD_DIR" -name "*.o")
    if [ -z "$OBJS" ]; then
        error "No object files found in $TARGET_DIR/$BUILD_DIR"
        return 1
    fi

    info "Linking $TARGET_DIR/$BIN_DIR/$EXEC..."
    gcc $OBJS -lm -ldl -fPIC -rdynamic -o "$TARGET_DIR/$BIN_DIR/$EXEC" || {
        error "Linking failed"
        return 1
    }
    return_to_original_dir
    return 0
}

# Function to build
build() {
    create_dirs || return $?
    compile_sources || return $?
    link_executable || return $?
    return 0
}

# Function to compare two files
files_are_different() {
    local file1="$1"
    local file2="$2"
    local newer_file=""
    
    # Check if both files exist
    if [ ! -f "$file1" ] || [ ! -f "$file2" ]; then
        # If either file doesn't exist, consider them different
        if [ ! -f "$file1" ]; then
            newer_file="$file2"
        else
            newer_file="$file1"
        fi
        export NEWER_FILE="$newer_file"
        return 0
    fi
    
    # Compare files byte by byte using cmp
    if cmp -s "$file1" "$file2"; then
        export NEWER_FILE=""
        return 1
    else
        # Determine which file is newer by comparing modification times
        if [ "$file1" -nt "$file2" ]; then
            newer_file="$file1"
        else
            newer_file="$file2"
        fi
        export NEWER_FILE="$newer_file"
        return 0
    fi
}

# Function to show usage
show_usage() { cat << EOF
                        graveyard - Usage Information                        
-----------------------------------------------------------------------------

Usage: graveyard <Target> [Flags]

Targets:
                  diff          : Checks for any diffs in bytes between the Installed graveyard and the graveyard in the Skull dir
                  resurrect     : Updates graveyard or if you dont have it installed it Installs graveyard to /usr/bin
                  lsc-compile   : Compiles LSC to a binary
                  lsc-remove    : Deletes the compiled LSC binary and its build artifacts
                  lsc-recompile : Recompiles LSC (Alternative: graveyard lsc-remove && graveyard lsc-compile)
                  lsc-install   : Compiles LSC and installs to /usr/bin
                  lsc-uninstall : Uninstalls LSC from /usr/bin
                  lsc-reinstall : Reinstalls LSC (Alternative: graveyard lsc-uninstall && graveyard lsc-install)
                  clear-log     : Deletes the log file (log.grv)
                  usage         : Display this help message

Flags:
                  -V            : Verbose (Displays info messages)
                  -Q            : Displays nothing at all except errors
                  --no-log      : Doesnt echo the output to a file
                  --no-warn     : Displays no warnings at all

Note: Flags and target can be specified in any order.

EOF
}

# Handler for lsc targets to preserve directory
handle_lsc_target() {
    # Navigate to Skull directory before running lsc commands
    navigate_to_skull_dir
    
    case "$TARGET" in
        lsc-compile)
            info "Compiling $EXEC..."
            build || { 
                error "Compilation failed"
                return $E_COMPILE_FAIL
            }
            success "$EXEC Compiled Successfully"
            ;;
        lsc-remove)
            info "Removing $EXEC build artifacts..."
            rm -rf "$TARGET_DIR" 2>/dev/null || {
                error "Failed to remove build artifacts"
                return $E_GENERAL
            }
            success "Build artifacts removed successfully"
            ;;
        lsc-recompile)
            info "Recompiling $EXEC..."
            info "Cleaning $TARGET_DIR..."
            rm -rf "$TARGET_DIR" 2>/dev/null || {
                warning "Failed to clean target directory"
            }
            build || {
                error "Recompilation failed"
                return $E_COMPILE_FAIL
            }
            success "Recompiled Successfully"
            ;;
        lsc-install)
            build || {
                error "Build failed during installation"
                return $E_COMPILE_FAIL
            }
            info "Installing $EXEC..."
            sudo cp -f "$TARGET_DIR/$BIN_DIR/$EXEC" "$USER_BIN/" || {
                error "Installation of $EXEC to $USER_BIN failed"
                return $E_INSTALL_FAIL
            }
            success "$EXEC Installed Successfully"
            ;;
        lsc-uninstall)
            info "Uninstalling $EXEC from system..."
            if [ -f "$USER_BIN/$EXEC" ]; then
                sudo rm -f "$USER_BIN/$EXEC" || {
                    error "Failed to remove $EXEC from $USER_BIN"
                    return $E_GENERAL
                }
                success "$EXEC uninstalled successfully from $USER_BIN"
            else
                warning "$EXEC not found in $USER_BIN, nothing to uninstall"
            fi
            ;;
        lsc-reinstall)
            info "Reinstalling $EXEC..."
            # First uninstall
            if [ -f "$USER_BIN/$EXEC" ]; then
                sudo rm -f "$USER_BIN/$EXEC" || {
                    error "Failed to remove $EXEC from $USER_BIN during reinstall"
                    return $E_GENERAL
                }
            fi
            # Clean build artifacts
            rm -rf "$TARGET_DIR" 2>/dev/null || {
                warning "Failed to clean target directory during reinstall"
            }
            # Then build and install
            build || {
                error "Build failed during reinstallation"
                return $E_COMPILE_FAIL
            }
            sudo cp -f "$TARGET_DIR/$BIN_DIR/$EXEC" "$USER_BIN/" || {
                error "Installation of $EXEC to $USER_BIN failed"
                return $E_INSTALL_FAIL
            }
            success "$EXEC Reinstalled Successfully"
            ;;
    esac
    return_to_original_dir
    return $E_SUCCESS
}

# Main function
main() {
    # Check for arguments
    if [ $# -eq 0 ]; then
        error "No arguments provided, Try graveyard usage..."
        show_usage
        exit $E_NO_TARGET
    fi

    # Parse all arguments
    parse_arguments "$@"
    
    # Find the Skull directory
    SKULL_DIR=$(find_skull_dir)
    if [ -z "$SKULL_DIR" ]; then
        error "Could not find a valid Skull directory with includes and src subdirectories"
        exit $E_GENERAL
    fi
    
    info "Found Skull directory at: $SKULL_DIR"
    
    # Check for gcc
    check_gcc || exit $E_MISSING_DEPS

    # Handle targets
    local result=$E_SUCCESS
    
    # Handle lsc* targets differently to preserve directory
    if [[ "$TARGET" == lsc-* ]]; then
        handle_lsc_target
        result=$?
    else     
        # Execute the target
        case "$TARGET" in
            diff)
                navigate_to_skull_dir
                if [ -f "$USER_BIN/graveyard" ] && [ -f "graveyard" ]; then
                    info "Checking Requirements: [Are Filesizes Different]..."
                    if files_are_different "$USER_BIN/graveyard" "graveyard"; then
                        success "Met Requirements: [Filesizes Are Different]!"
                    else
                        warning "Unmet Requirements: [Filesizes Are Not Different]!"
                    fi
                else
                    if [ ! -f "$USER_BIN/graveyard" ]; then
                        warning "graveyard file not found in $USER_BIN"
                    fi
                    if [ ! -f "graveyard" ]; then
                        warning "graveyard file not found in $(pwd)"
                    fi
                    result=$E_GENERAL
                fi
                navigate_to_skull_dir
                ;;
            resurrect)
                navigate_to_skull_dir
                if [ -f "$USER_BIN/graveyard" ] && [ -f "graveyard" ]; then
                    info "Updating graveyard..."
                    sudo cp -f "graveyard" "$USER_BIN/" || {
                        error "Failed to update graveyard"
                        result=$E_INSTALL_FAIL
                    }
                    success "Graveyard Updated Successfully"
                else
                    if [ -f "graveyard" ] && [ ! -f "$USER_BIN/graveyard" ]; then
                        info "Installing graveyard systemwide..."
                        sudo cp -f "graveyard" "$USER_BIN/" || {
                            error "Failed to install graveyard"
                            result=$E_INSTALL_FAIL
                        }
                        success "Graveyard Installed Successfully"
                    else
                        error "Graveyard file not found in $(pwd))"
                        result=$E_GENERAL
                    fi
                fi
                ;;
            clear-log)
                navigate_to_skull_dir
                info "Clearing log file..."
                if [ -f "$LOG_FILE" ]; then
                    rm -f "$LOG_FILE" || {
                        error "Failed to remove log file"
                        result=$E_GENERAL
                    }
                    success "Log file cleared successfully"
                else
                    warning "No log file found at $LOG_FILE"
                fi
                return_to_original_dir
                ;;
            usage)
                show_usage
                ;;
        esac
    fi

    return_to_original_dir

    exit $result
}

# Call the main function with all script arguments
main "$@"
