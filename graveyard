#!/bin/bash

# graveyard - Build and installation manager for LSC (Skull compiler)
# Improved version with better error handling and logic that matches README.md definitions

# Exit codes
readonly E_SUCCESS=0
readonly E_GENERAL=1
readonly E_NO_TARGET=2
readonly E_INVALID_TARGET=3
readonly E_MISSING_DEPS=4
readonly E_COMPILE_FAIL=5
readonly E_INSTALL_FAIL=6

# Define paths and variables
readonly USER_BIN="/usr/bin"
readonly EXEC="lsc"
readonly BUILD_DIR="build"
readonly BIN_DIR="bin"
readonly TARGET_DIR="target"
readonly SRC_DIR="src"
readonly INCLUDE_DIR="includes"

# Compiler flags
readonly IMPL_FLAGS="-DSKULL_LIST_H_IMPLEMENTATION -DSKULL_AST_H_IMPLEMENTATION \
 -DSKULL_TOKEN_H_IMPLEMENTATION -DSKULL_LEXER_H_IMPLEMENTATION \
 -DSKULL_PARSER_H_IMPLEMENTATION -DSKULL_TYPES_H_IMPLEMENTATION \
 -DSKULL_UTILS_H_IMPLEMENTATION -DSKULL_ASM_H_IMPLEMENTATION \
 -DSKULL_H_IMPLEMENTATION"
readonly CFLAGS="-g -Wall -I$INCLUDE_DIR $IMPL_FLAGS"
readonly LDFLAGS="-lm -ldl -fPIC -rdynamic"

# All valid targets - updated to match README.md
readonly VALID_TARGETS="diff resurrect lsc-compile lsc-remove lsc-recompile lsc-install lsc-uninstall lsc-reinstall usage"

# Function to display error messages
error() {
    echo "[Graveyard_ERROR]: $1" >&2
}

# Function to display success messages
success() {
    echo "[Graveyard_SUCCESS]: $1"
}

# Function to display informational messages
info() {
    echo "$1"
}

# Function to locate the Skull directory
find_skull_dir() {
    local head_dir
    head_dir="$(basename "$(pwd)")"
    
    if [ "$head_dir" = "Skull" ] && [ -d "includes" ] && [ -d "src" ]; then
        pwd
        return 0
    else
        # Find all Skull directories in HOME
        local skull_dirs=()
        mapfile -t skull_dirs < <(sudo find "$HOME" -name "Skull" -type d 2>/dev/null)
        
        # Loop through found directories
        for candidate in "${skull_dirs[@]}"; do
            if [ -d "$candidate/includes" ] && [ -d "$candidate/src" ]; then
                echo "$candidate"
                return 0
            fi
        done
    fi
    
    return 1
}

# Function to check if gcc is installed
check_gcc() {
    if ! command -v gcc >/dev/null 2>&1; then
        info "gcc is not installed. Installing gcc..."
        sudo pacman -Sy gcc || {
            error "Failed to install gcc"
            return 1
        }
        if ! command -v gcc >/dev/null 2>&1; then
            error "Failed to install gcc"
            return 1
        fi
    fi
    return 0
}

# Function to create directories
create_dirs() {
    mkdir -p "$TARGET_DIR" "$TARGET_DIR/$BUILD_DIR" "$TARGET_DIR/$BIN_DIR" || {
        error "Failed to create directories"
        return 1
    }
    return 0
}

# Function to compile source files
compile_sources() {
    # Find all .c files in src directory
    local SRCS
    SRCS=$(find "$SRC_DIR" -name "*.c" -type f)
    if [ -z "$SRCS" ]; then
        error "No source files found in $SRC_DIR"
        return 1
    fi

    # Compile each source file to object file
    for src in $SRCS; do
        local obj
        obj="$TARGET_DIR/$BUILD_DIR/$(basename "${src%.c}.o")"
        info "Compiling $src to $obj..."
        gcc $CFLAGS -c "$src" -o "$obj" || {
            error "Compilation of $src failed"
            return 1
        }
    done
    return 0
}

# Function to link object files
link_executable() {
    # Find all object files
    local OBJS
    OBJS=$(find "$TARGET_DIR/$BUILD_DIR" -name "*.o")
    if [ -z "$OBJS" ]; then
        error "No object files found in $TARGET_DIR/$BUILD_DIR"
        return 1
    fi

    info "Linking $TARGET_DIR/$BIN_DIR/$EXEC..."
    gcc $OBJS $LDFLAGS -o "$TARGET_DIR/$BIN_DIR/$EXEC" || {
        error "Linking failed"
        return 1
    }
    return 0
}

# Function to build
build() {
    create_dirs || return $?
    compile_sources || return $?
    link_executable || return $?
    return 0
}

# Function to compare two files
files_are_different() {
    local file1="$1"
    local file2="$2"
    local newer_file=""
    
    # Check if both files exist
    if [ ! -f "$file1" ] || [ ! -f "$file2" ]; then
        # If either file doesn't exist, consider them different
        if [ ! -f "$file1" ]; then
            newer_file="$file2"
        else
            newer_file="$file1"
        fi
        export NEWER_FILE="$newer_file"
        return 0
    fi
    
    # Compare files byte by byte using cmp
    if cmp -s "$file1" "$file2"; then
        export NEWER_FILE=""
        return 1
    else
        # Determine which file is newer by comparing modification times
        if [ "$file1" -nt "$file2" ]; then
            newer_file="$file1"
        else
            newer_file="$file2"
        fi
        export NEWER_FILE="$newer_file"
        return 0
    fi
}

# Function to show usage
show_usage() { cat << EOF
                        graveyard - Usage Information                        
-----------------------------------------------------------------------------

Usage: graveyard <Target>

Targets:
                  diff          : Checks for any diffs in bytes between the Installed graveyard and the graveyard in the Skull dir
                  resurrect     : Updates graveyard or if you dont have it installed it Installs graveyard to /usr/bin
                  lsc-compile   : Compiles LSC to a binary
                  lsc-remove    : Deletes the compiled LSC binary and its build artifacts
                  lsc-recompile : Recompiles LSC (Alternative: graveyard lsc-remove && graveyard lsc-compile)
                  lsc-install   : Compiles LSC and installs to /usr/bin
                  lsc-uninstall : Uninstalls LSC from /usr/bin
                  lsc-reinstall : Reinstalls LSC (Alternative: graveyard lsc-uninstall && graveyard lsc-install)
                  usage         : Display this help message

EOF
}

# Main function
main() {
    # Find the Skull directory
    SKULL_DIR=$(find_skull_dir)
    if [ -z "$SKULL_DIR" ]; then
        error "Could not find a valid Skull directory with includes and src subdirectories"
        exit $E_GENERAL
    fi
    info "Found Skull directory at: $SKULL_DIR"
    
    # Check for gcc
    check_gcc || exit $E_MISSING_DEPS
    
    # Check for target argument
    if [ $# -eq 0 ]; then
        info "No Targets Provided, Try graveyard usage..."
        exit $E_NO_TARGET
    fi

    # Get target and validate
    TARGET="$1"
    if ! echo "$VALID_TARGETS" | grep -qw "$TARGET"; then
        error "Invalid target '$TARGET'. Valid targets are: $VALID_TARGETS"
        show_usage
        exit $E_INVALID_TARGET
    fi

    # Handle targets
    cd "$SKULL_DIR" || {
        error "Failed to change to Skull directory"
        exit $E_GENERAL
    }
    
    case "$TARGET" in
        diff)
            if [ -f "$USER_BIN/graveyard" ] && [ -f "$SKULL_DIR/graveyard" ]; then
                info "Checking Requirements: [Are Filesizes Different]..."
                if files_are_different "$USER_BIN/graveyard" "$SKULL_DIR/graveyard"; then
                    info "Met Requirements: [Filesizes Are Different]!"
                else
                    info "Unmet Requirements: [Filesizes Are Not Different]!"
                    exit $E_SUCCESS
                fi
            else
                if [ ! -f "$USER_BIN/graveyard" ]; then
                    info "graveyard file not found in $USER_BIN"
                fi
                if [ ! -f "$SKULL_DIR/graveyard" ]; then
                    error "graveyard file not found in $SKULL_DIR"
                fi
                exit $E_GENERAL
            fi
            ;;
        resurrect)
            if [ -f "$USER_BIN/graveyard" ] && [ -f "$SKULL_DIR/graveyard" ]; then
                info "Checking Requirements: [Are Filesizes Different]..."
                if files_are_different "$USER_BIN/graveyard" "$SKULL_DIR/graveyard"; then
                    info "Met Requirements: [Filesizes Are Different]!"
                    info "Updating graveyard..."
                    sudo cp -f "$SKULL_DIR/graveyard" "$USER_BIN/" || {
                        error "Failed to update graveyard"
                        exit $E_INSTALL_FAIL
                    }
                    success "graveyard Updated Successfully"
                else
                    info "Unmet Requirements: [Filesizes Are Not Different]!"
                    info "No update needed..."
                fi
            else
                if [ -f "$SKULL_DIR/graveyard" ] && [ ! -f "$USER_BIN/graveyard" ]; then
                    info "Installing graveyard for the first time..."
                    sudo cp -f "$SKULL_DIR/graveyard" "$USER_BIN/" || {
                        error "Failed to install graveyard"
                        exit $E_INSTALL_FAIL
                    }
                    success "graveyard Installed Successfully"
                else
                    error "graveyard file not found in $SKULL_DIR"
                    exit $E_GENERAL
                fi
            fi
            ;;
        lsc-compile)
            info "Compiling $EXEC..."
            build || exit $E_COMPILE_FAIL
            success "$EXEC Compiled Successfully"
            ;;
        lsc-remove)
            info "Removing $EXEC build artifacts..."
            rm -rf "$TARGET_DIR" 2>/dev/null
            success "Build artifacts removed successfully"
            ;;
        lsc-recompile)
            info "Recompiling $EXEC..."
            info "Cleaning $TARGET_DIR..."
            rm -rf "$TARGET_DIR" 2>/dev/null
            build || exit $E_COMPILE_FAIL
            success "Recompiled Successfully"
            ;;
        lsc-install)
            build || exit $E_COMPILE_FAIL
            info "Installing $EXEC..."
            sudo cp -f "$TARGET_DIR/$BIN_DIR/$EXEC" "$USER_BIN/" || {
                error "Installation of $EXEC to $USER_BIN failed"
                exit $E_INSTALL_FAIL
            }
            success "$EXEC Installed Successfully"
            ;;
        lsc-uninstall)
            info "Uninstalling $EXEC from system..."
            if [ -f "$USER_BIN/$EXEC" ]; then
                sudo rm -f "$USER_BIN/$EXEC" || {
                    error "Failed to remove $EXEC from $USER_BIN"
                    exit $E_GENERAL
                }
                success "$EXEC uninstalled successfully from $USER_BIN"
            else
                info "$EXEC not found in $USER_BIN, nothing to uninstall"
            fi
            ;;
        lsc-reinstall)
            info "Reinstalling $EXEC..."
            # First uninstall
            if [ -f "$USER_BIN/$EXEC" ]; then
                sudo rm -f "$USER_BIN/$EXEC" || {
                    error "Failed to remove $EXEC from $USER_BIN during reinstall"
                    exit $E_GENERAL
                }
            fi
            # Clean build artifacts
            rm -rf "$TARGET_DIR" 2>/dev/null
            # Then build and install
            build || exit $E_COMPILE_FAIL
            sudo cp -f "$TARGET_DIR/$BIN_DIR/$EXEC" "$USER_BIN/" || {
                error "Installation of $EXEC to $USER_BIN failed"
                exit $E_INSTALL_FAIL
            }
            success "$EXEC Reinstalled Successfully"
            ;;
        usage)
            show_usage
            ;;
    esac

    exit $E_SUCCESS
}

# Call the main function with all script arguments
main "$@"
